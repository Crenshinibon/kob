# Database Schema Design

## Overview

This specification defines the complete database schema for the KoB Tracker using Drizzle ORM with PostgreSQL. The schema supports tournaments, courts, rounds, matches, and player management with proper relationships and constraints.

## Schema Files

**Primary Schema**: `src/lib/server/db/schema.ts`
**Auth Schema**: `src/lib/server/db/auth.schema.ts` (auto-generated by Better Auth)

## Entity Relationship Diagram

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│     User        │     │    Tournament    │     │  CourtAccess    │
├─────────────────┤     ├──────────────────┤     ├─────────────────┤
│ id (PK)         │◄────┤ id (PK)          │────►│ id (PK)         │
│ email           │     │ org_id (FK)      │     │ tournament_id   │
│ name            │     │ name             │     │ court_number    │
│ ...             │     │ status           │     │ round_number    │
└─────────────────┘     │ current_round    │     │ access_token    │
                        │ num_rounds       │     │ is_active       │
                        │ created_at       │     └─────────────────┘
                        └──────────────────┘
                                 │
                    ┌────────────┴────────────┐
                    ▼                         ▼
          ┌─────────────────┐      ┌──────────────────┐
          │  CourtRotation  │      │     Round        │
          ├─────────────────┤      ├──────────────────┤
          │ id (PK)         │      │ id (PK)          │
          │ tournament_id   │      │ tournament_id    │
          │ round_number    │      │ round_number     │
          │ court_number    │      │ status           │
          │ player_1_id     │      │ started_at       │
          │ player_2_id     │      │ closed_at        │
          │ player_3_id     │      └──────────────────┘
          │ player_4_id     │
          └─────────────────┘
                    │
                    ▼
          ┌─────────────────┐
          │     Match       │
          ├─────────────────┤
          │ id (PK)         │
          │ court_id (FK)   │
          │ match_number    │
          │ team_a_player_1 │
          │ team_a_player_2 │
          │ team_b_player_1 │
          │ team_b_player_2 │
          │ team_a_score    │
          │ team_b_score    │
          │ is_complete     │
          └─────────────────┘
```

## Table Specifications

### 1. Tournament Table

**Purpose**: Stores tournament metadata and state.

**Fields**:
```typescript
{
  id: serial('id').primaryKey(),
  org_id: text('org_id').notNull(), // References Better Auth user.id
  name: text('name').notNull(),
  status: text('status').notNull().default('draft'), // 'draft', 'active', 'completed', 'archived'
  current_round: integer('current_round').default(0),
  num_rounds: integer('num_rounds').notNull().default(3),
  seeding_mode: text('seeding_mode').notNull().default('random'), // 'random', 'manual'
  created_at: timestamp('created_at').defaultNow(),
  updated_at: timestamp('updated_at').defaultNow()
}
```

**Constraints**:
- `org_id` references `user.id` (Better Auth user table)
- `status` must be one of: 'draft', 'active', 'completed', 'archived'
- `num_rounds` must be between 1 and 10 (MVP constraint)

**Indexes**:
- Index on `org_id` for fetching user's tournaments
- Index on `status` for filtering active tournaments

### 2. Player Table

**Purpose**: Stores player information within a tournament.

**Fields**:
```typescript
{
  id: serial('id').primaryKey(),
  tournament_id: integer('tournament_id').notNull(),
  name: text('name').notNull(),
  initial_seed: integer('initial_seed'), // For manual seeding
  final_rank: integer('final_rank'), // Set at tournament completion
  created_at: timestamp('created_at').defaultNow()
}
```

**Constraints**:
- Foreign key to `tournament.id` with CASCADE delete
- Unique constraint on `(tournament_id, name)` to prevent duplicates
- Exactly 16 players per tournament enforced at application level

**Indexes**:
- Index on `tournament_id` for fetching tournament players

### 3. CourtRotation Table

**Purpose**: Defines player assignments to courts for each round.

**Fields**:
```typescript
{
  id: serial('id').primaryKey(),
  tournament_id: integer('tournament_id').notNull(),
  round_number: integer('round_number').notNull(),
  court_number: integer('court_number').notNull(), // 1-4
  player_1_id: integer('player_1_id').notNull(),
  player_2_id: integer('player_2_id').notNull(),
  player_3_id: integer('player_3_id').notNull(),
  player_4_id: integer('player_4_id').notNull()
}
```

**Constraints**:
- Foreign keys to `player.id` for all player fields
- Foreign key to `tournament.id` with CASCADE delete
- Unique constraint on `(tournament_id, round_number, court_number)`
- `court_number` must be between 1 and 4
- All 4 player IDs must be distinct

**Indexes**:
- Composite index on `(tournament_id, round_number)` for fetching round data
- Index on `tournament_id` for fetching all rotations

### 4. Match Table

**Purpose**: Stores individual match results within a court rotation.

**Fields**:
```typescript
{
  id: serial('id').primaryKey(),
  court_rotation_id: integer('court_rotation_id').notNull(),
  match_number: integer('match_number').notNull(), // 1-3
  // Team A (partners)
  team_a_player_1_id: integer('team_a_player_1_id').notNull(),
  team_a_player_2_id: integer('team_a_player_2_id').notNull(),
  // Team B (partners)
  team_b_player_1_id: integer('team_b_player_1_id').notNull(),
  team_b_player_2_id: integer('team_b_player_2_id').notNull(),
  // Scores
  team_a_score: integer('team_a_score'), // NULL until entered
  team_b_score: integer('team_b_score'), // NULL until entered
  is_complete: boolean('is_complete').default(false),
  entered_at: timestamp('entered_at'),
  entered_by: text('entered_by') // 'org' or court token
}
```

**Constraints**:
- Foreign key to `court_rotation.id` with CASCADE delete
- Foreign keys to `player.id` for all player fields
- Unique constraint on `(court_rotation_id, match_number)`
- `match_number` must be 1, 2, or 3
- All 4 player IDs in a match must be distinct
- `team_a_player_1_id < team_a_player_2_id` (consistent ordering)
- `team_b_player_1_id < team_b_player_2_id` (consistent ordering)

**Indexes**:
- Index on `court_rotation_id` for fetching court matches

### 5. CourtAccess Table

**Purpose**: Manages access tokens for anonymous players to enter scores.

**Fields**:
```typescript
{
  id: serial('id').primaryKey(),
  tournament_id: integer('tournament_id').notNull(),
  court_rotation_id: integer('court_rotation_id').notNull(),
  access_token: text('access_token').notNull(),
  is_active: boolean('is_active').default(true),
  created_at: timestamp('created_at').defaultNow()
}
```

**Constraints**:
- Foreign key to `tournament.id` with CASCADE delete
- Foreign key to `court_rotation.id` with CASCADE delete
- Unique constraint on `access_token`
- Unique constraint on `(court_rotation_id)` (one token per court per round)

**Indexes**:
- Index on `access_token` for token validation lookups
- Index on `tournament_id` for fetching all court tokens

## Schema Relationships

### Cascading Deletes

When a tournament is deleted:
- All players are deleted (CASCADE)
- All court rotations are deleted (CASCADE)
- All matches are deleted (via court_rotation CASCADE)
- All court access tokens are deleted (CASCADE)

### Data Integrity

**Application-Level Enforcement**:
1. Exactly 16 players per tournament
2. Exactly 4 court rotations per round
3. Exactly 3 matches per court rotation
4. Player IDs in matches correspond to rotation player IDs
5. All matches complete before round can close

## Migration Strategy

**Initial Migration**:
```bash
npm run db:generate
npm run db:push
```

**Schema Updates**:
1. Modify `src/lib/server/db/schema.ts`
2. Run `npm run db:generate` to create migration
3. Run `npm run db:migrate` to apply changes
4. Test migration on staging before production

## Query Patterns

### Common Queries

**Get tournament with all data**:
```typescript
const tournament = await db.query.tournament.findFirst({
  where: eq(tournament.id, tournamentId),
  with: {
    players: true,
    rotations: {
      with: {
        matches: true
      }
    }
  }
});
```

**Get current round standings for a court**:
```typescript
const matches = await db.query.match.findMany({
  where: eq(courtRotation.id, rotationId),
  with: {
    rotation: true
  }
});
```

**Validate court access token**:
```typescript
const access = await db.query.courtAccess.findFirst({
  where: and(
    eq(courtAccess.accessToken, token),
    eq(courtAccess.isActive, true)
  ),
  with: {
    rotation: {
      with: {
        matches: true
      }
    }
  }
});
```

## Performance Considerations

1. **Indexes**: All foreign keys and frequently queried fields are indexed
2. **Connection Pooling**: Neon handles connection pooling automatically
3. **Query Optimization**: Use Drizzle's relational queries for nested data
4. **Caching**: Consider caching tournament standings calculation (Redis future)

## Testing Strategy

**Database Tests**:
1. Schema migration runs without errors
2. Foreign key constraints prevent invalid data
3. CASCADE deletes work correctly
4. Unique constraints prevent duplicates
5. Query performance on 16 players × 4 courts × 3 matches × N rounds

**Seed Data for Testing**:
- Create test tournament with 16 players
- Generate 3 rounds with rotations
- Enter sample scores for all matches
- Verify standings calculations
